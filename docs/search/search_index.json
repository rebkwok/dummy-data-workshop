{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to the workshop","text":"<p>Go to https://opensafely.github.io/dummy-data-workshop to follow along.</p>"},{"location":"#prerequisites","title":"Prerequisites","text":""},{"location":"#github-and-codespaces","title":"GitHub and Codespaces","text":"<p>We will use a GitHub repository and Codespaces for this workshop. You will need a personal GitHub account. Follow the instructions to setup your codespace.</p>"},{"location":"#ehrql","title":"ehrql","text":"<p>The ehrQL code that we'll look at in this workshop is not very complicated, however, it is assumed that you are not completely new to ehrQL. If you need a reminder, please see the ehrQL checklist and the  ehrql documentation.</p>"},{"location":"#r","title":"R","text":"<p>Some previous experience writing code in R is recommended.</p>"},{"location":"#setup-your-codespace","title":"Setup your codespace","text":"<p>Please go to https://github.com/opensafely/dummy-data-workshop</p> <p>Click on the \"Use this template\" button, and select \"Open in a workspace\"</p> <p></p> <p>The codespace will take several minutes to launch. Please wait!</p> <p>Warning</p> <p>The codespace will launch with the updated version of ehrQL and R that you need for this workshop. You should ignore any terminal reminders to run <code>opensafely pull</code>, as this will replace the custom R images that we are using. If you need to, you can update the R images again by running <code>update_r</code> in your codespace terminal.</p>"},{"location":"#notes","title":"Notes","text":"<p>We'll use some icons in parts of this tutorial:</p> <p> For when we're looking at or modifying some code in a file.</p> <p> For when we need to run a command in the terminal</p> <p>Suggested exercises</p> <p>Blocks like this indication suggested exercises to try, or ways to experiment; we won't necessarily have time to go through these during the workshop, but you might want to come back to them in the time at the end of the session, or afterwards.</p>"},{"location":"dummy_data_in_opensafely/","title":"Dummy data in OpenSAFELY","text":""},{"location":"dummy_data_in_opensafely/#what-is-dummy-data","title":"What is dummy data?","text":"<p>Dummy data (in the context of OpenSAFELY) is data that mimics the output of a dataset produced by running an ehrQL generate-dataset action, in the absence of the real data. It allows you to test and develop your analyses without access to the real data.</p> <p>When you run an ehrQL command or a <code>project.yaml</code> action locally (i.e. outside of the secure  environment where real patient data lives), ehrQL allows the action to run using simulated data, either data generated by ehrQL itself, data that you provide. </p>"},{"location":"dummy_data_in_opensafely/#using-dummy-data-in-opensafely","title":"Using dummy data in OpenSAFELY","text":"<p>There are 3 ways to use dummy data:</p> <ol> <li>Allow ehrQL to generate a dummy dataset from your dataset definition</li> <li>Provide your own dummy tables</li> <li>Provide your own dummy dataset</li> </ol>"},{"location":"dummy_data_in_opensafely/#generate-a-dummy-dataset-with-ehrql","title":"Generate a dummy dataset with ehrQL","text":"<p> <code>analysis/dataset_definition.py</code></p> <p>This example is a very minimal dataset definition, which finds patients between 18 and 80, and adds their age and sex to the output dataset:</p> <pre><code>from ehrql import create_dataset\nfrom ehrql.tables.core import patients\n\ndataset = create_dataset()\n\nindex_date = \"2020-03-31\"\n\nage = patients.age_on(index_date)\n\ndataset.define_population((age &gt; 18) &amp; (age &lt; 80))\ndataset.age = age\ndataset.sex = patients.sex\n</code></pre> <p> Try generating a dummy dataset. In the terminal, run:</p> <pre><code>opensafely exec ehrql:v1 generate-dataset analysis/dataset_definition.py\n</code></pre> <p><code>opensafely exec</code> vs <code>opensafely run</code></p> <p>We will be using <code>opensafely exec</code> for this part of the workshop. This lets us run ehrQL commands as standalone actions. Refer to the documentation on running ehrQL for more information.</p> <p>By default, this will generate 10 patients and will print them to the terminal, e.g.</p> <pre><code>patient_id,age,sex\n1,29,unknown\n2,24,male\n3,58,unknown\n6,29,unknown\n9,61,intersex\n10,57,male\n11,69,female\n14,76,unknown\n15,23,male\n17,25,unknown\n</code></pre> <p>Note that all 10 patients have been generated with ages within the expected range (18-80, as defined in the dataset definition) and sex in one of the 4 possible values.</p> <p>Update the dataset definition</p> <p>Try updating the dataset definition to filter to only female patients. Rerun the <code>generate-dataset</code> command, and confirm that the output dataset now contains 10 female patients.</p> <p>If you want to produce a different number of patients, you can configure your dummy data by adding:</p> <pre><code>dataset.configure_dummy_data(population_size=50)\n</code></pre> <p>Change population size</p> <p>Try re-running the <code>generate-dataset</code> command above, but with a different poulation size.</p>"},{"location":"dummy_data_in_opensafely/#characteristics-of-native-dummy-data-in-opensafely","title":"Characteristics of native dummy data in OpenSAFELY","text":"<p>Dummy data produced from a dataset definition is:</p> <ul> <li> <p>structurally valid; it will contain the correct columns and data in each column will be of the correct type. Where a column contains categorical data, the column values will respect the categories.  These could be built into ehrQL's definition of the underlying table (e.g. sex in the previous example) or they could be defined in the dataset definition.</p> </li> <li> <p>logically valid; it will respect logic within the dataset definition itself. For example, it won't produce a clinical event date before a patient's date of birth or after their date of death.</p> </li> </ul> <p> try this out by updating <code>analysis/dataset_definition.py</code>:</p> <pre><code>from ehrql.tables.core import patients, clinical_events\n...\nevents = clinical_events.sort_by(clinical_events.date).first_for_patient()\ndataset.event_date = events.date\ndataset.dob_year = patients.date_of_birth.year\ndataset.dod_year = patients.date_of_death.year\n</code></pre> <ul> <li>consistent across multiple runs of the same dataset definition; although the data generated is random, it is \"seeded\", which means that the same data will be generated each time.</li> </ul> <p>Check dummy datasets are consistent</p> <p>Confirm for yourself that dummy datasets are consitent running the <code>generate-dataset</code> command several times and checking the output dataset from each run.</p> <pre><code>opensafely exec ehrql:v1 generate-dataset analysis/dataset_definition.py\n</code></pre>"},{"location":"dummy_data_in_opensafely/#provide-your-own-dummy-tables","title":"Provide your own dummy tables","text":"<p>You can also provide your own dummy tables. ehrQL will use the dummy tables as the backend data from which to extract the dataset. You can refer to the table schema reference in the OpenSAFELY documentation for a guide to the available tables and columns.</p> <p>However, setting up lots of dummy tables can be tedious. ehrQL generates dummy datasets by first creating dummy tables, and then running the dataset definition on them. We can use this to create dummy tables from a dataset definition, rather than just a dummy dataset.</p> <p> Using our updated dataset definition file, create dummy tables and write them to a local folder called <code>dummy_tables</code></p> <pre><code>opensafely exec ehrql:v1 create-dummy-tables analysis/dataset_definition.py dummy_tables\n</code></pre> <p> Have a look at the files that have been created in the <code>dummy_tables</code> folder; there will be 2  csv files corresponding to the two tables that this dataset definition uses.</p> <p></p> <p>Now that we have some dummy tables, we can take advantage of a new feature, the ehrQL debug command from the new OpenSAFELY VSCode extension.</p> <p> Update the dataset definition to add a debug statement before and after our definition of events. Here we can have a look at the date column from the full (dummy) clinical events table, and then the column after we've filtered to just the first event for each patient.</p> <pre><code>from ehrql import create_dataset, debug\n...\ndebug(clinical_events.date)\nevents = clinical_events.sort_by(clinical_events.date).first_for_patient()\ndebug(events.date)\n...\n</code></pre> <p>Click on the \"Debug ehrQL\" button in the bottom right.</p> <p></p> <p>This will open a new panel and display the columns we asked to debug.</p> <p></p> <p>Once you've created some dummy tables, you can then use those tables as the input when you run your dataset definition again locally. Or you can use them as a starting point to generate more data, or to test your dataset definition is extracting data as you\u2019d expect.</p> <p> To run our dataset extraction again, this time with the dummy tables: <pre><code>opensafely exec ehrql:v1 generate-dataset analysis/dataset_definition.py --dummy-tables dummy_tables\n</code></pre></p>"},{"location":"dummy_data_in_opensafely/#generating-dummy-tables","title":"Generating dummy tables","text":"<p>Another strategy is to use ehrQL to build the dummy tables you want, and then feed those into your dataset definition to see if it extracts the patients you expect.</p>"},{"location":"dummy_data_in_opensafely/#example","title":"Example","text":"<p>We want to extract patients who 18-80 and are in the city of London (E02000001). To do this, we've written the dataset definition at <code>analysis/dataset_definition_london_adults.py</code></p> <p> <pre><code>...\n\nlondon_msoa = (\n    addresses\n    .where((addresses.msoa_code==\"E02000001\") &amp;  addresses.msoa_code.is_not_null())\n   .sort_by(addresses.end_date)\n   .last_for_patient()\n)\n\ndataset.define_population((age &gt;= min_age) &amp; (age &lt;= max_age) &amp; london_msoa.exists_for_patient())\ndataset.msoa = london_msoa.msoa_code\n</code></pre></p> <p>If we ask ehrQL to generate dummy tables from the dataset definition, all patients will have MSOA E02000001, because that makes them satisfy the dataset definition.</p> <p> Run this dataset definition</p> <pre><code>opensafely exec ehrql:v1 generate-dataset analysis/dataset_definition_london_adults.py\n</code></pre> <p> The output is a dataset, all with the correct MSOA code. <pre><code>[info   ] Building dataset and writing results\npatient_id,msoa\n1,E02000001\n2,E02000001\n3,E02000001\n4,E02000001\n5,E02000001\n6,E02000001\n7,E02000001\n8,E02000001\n10,E02000001\n11,E02000001\n</code></pre></p> <p>Output the dummy tables:</p> <p> </p> <pre><code>opensafely exec ehrql:v1 create-dummy-tables analysis/dataset_definition_london_adults.py dummy_tables\n</code></pre> <p>The addresses.csv table that has been produced ONLY contains null values and the code E02000001 (which is present for every patient in at least one row).</p> <p>But, we want to make sure that our dataset definition successfully extracts patients with MSOA code E02000001 from patients with other MSOAs, and patients who have no MSOA available at all. And we want to check that it can extract patients of the right age from wider data; i.e. does it properly exclude patients who are too old/young?</p> <p> <code>analysis/dummy_data_definition_london_adults.py</code></p> <p>To do this, let's write a different dataset definition that just produces the tables. This will include the data we want, but also allows for producing patients who have no address data, patients whose MSOA code is different, and patients who are outside the age range.</p> <p>We define some possible MSOAs, including the target \"E02000001\".</p> <p> <pre><code>...\npossible_msoas = [\"E02000001\", \"E02000002\", \"E02000003\", \"E02000004\"]\n</code></pre></p> <p>Now define an address variable that selects patients who have data in the addresses table, where the MSOA code is one of these possible codes, or none.</p> <p> <pre><code>address = (\n   addresses\n   .where(\n       (addresses.msoa_code.is_in(possible_msoas) |  addresses.msoa_code.is_null())\n   )\n   .sort_by(addresses.end_date)\n   .last_for_patient()\n)\n</code></pre> And define a variable that selects patients who have NO address data:</p> <p> <pre><code>no_address = ~addresses.exists_for_patient()\n</code></pre></p> <p>Add the age column to the output dataset - this will make sure relevant columns are included in the dummy patient table. We also add the msoa code, just so we can check what's being produced.</p> <p></p> <pre><code>dataset.age = patients.age_on(index_date)\ndataset.msoa = address.msoa_code\n</code></pre> <p>Finally, define our population to include patients of any age, who either have a matching address or no address data at all.</p> <p></p> <pre><code>dataset.define_population(patients.exists_for_patient() &amp; (address.exists_for_patient() | no_address))\n</code></pre> <p> Generate a dataset; we get a set of patients, only some of whom will match our actual dataset definition.</p> <pre><code>[info   ] Building dataset and writing results\npatient_id,age,msoa\n1,33,E02000004\n2,28,E02000004\n3,62,E02000001\n4,14,\n5,112,E02000002\n6,33,E02000004\n7,85,E02000004\n8,19,\n9,64,\n10,61,E02000001\n</code></pre> <p>Output these dummy tables:  </p> <pre><code>opensafely exec ehrql:v1 create-dummy-tables analysis/dummy_data_definition_london_adults.py dummy_tables\n</code></pre> <p>Now use them to run the actual dataset definition:</p> <p> </p> <p><pre><code>opensafely exec ehrql:v1 generate-dataset analysis/dataset_definition_london_adults.py --dummy-tables dummy_tables\n</code></pre> And we can verify that our dataset definition is indeed extracting only the patients who match our criteria: </p> <pre><code>[info   ] Building dataset and writing results\npatient_id,age,msoa\n1,33,E02000001\n10,61,E02000001\n3,62,E02000001\n6,33,E02000001\n</code></pre> <p>Exercise: Covid boosters</p> <p><code>analysis/dataset_definition_covid_boosters.py</code> is a dataset definition that identifies the type of Covid vaccine patients received in Spring 2023, and extracts information about where the patients live. We expect that a downstream analysis script will use this data to analyse regional variations if the type of vaccine received.</p> <p>First try running this dataset definition and look at the dummy dataset it produces. As vaccine product names are not defined in ehrQL, it can only produce random data that matches the expected pattern for a product name (i.e. a string of characters), and not real product names.</p> <p>Write a dummy tables dataset definition that will create dummy tables that can be used to run the dataset definition at <code>analysis/dataset_definition_covid_boosters.py</code> and produce vaccines with valid product names. Your dummy tables should also include vaccinations that are not Covid vaccines, in order to test that the dataset definition correctly filters them out.</p> <p>( Hint: You may want to make use of the data at <code>analysis/supporting_data/vaccine_product_names.py</code>)</p>"},{"location":"dummy_data_in_opensafely/#limitations-of-native-opensafely-dummy-data","title":"Limitations of native OpenSAFELY dummy data","text":"<ul> <li>Complex dataset definitions may take a long time to generate patients</li> <li>...or may not be able to generate the requested number of patients</li> <li>Certain fields will generate values that are valid in format, but are not necessarily real data. E.g. SNOMED CT codes may be generated in a valid format, but may not be real codes.      e.g. The following will produce codes that look like SNOMED CT codes, but are randomly generated.     Any further analysis which tries to use the code to filter or summarise data will fail to     match expected data.      <pre><code>code = clinical_events.sort_by(clinical_events.date).first_for_patient().snomedct_code\n</code></pre>     (To some extent building up your dummy data tables can work around this sort of thing.)</li> <li> <p>Semantic validity is difficult to ensure in generated dummy data</p> <ul> <li> <p>Certain interactions between tables/columns that should reflect reality will not necessarily be   respected unless they are specified in the dataset definition, e.g.</p> <ul> <li>no consultations after death</li> <li>no discharge before admission</li> <li>no COVID-19 vaccines before 2020</li> </ul> <p>(Although note that such events could happen in the real data.)</p> </li> <li> <p>Demographic or clinical tendencies that are expected in the cohort of interest, e.g.</p> <ul> <li>more white people than black people in England</li> <li>correlation between obesity and diabetes</li> <li>statins more commonly prescribed in over 50s</li> </ul> </li> </ul> </li> </ul> <p>Admission and discharge dates</p> <p>An example of semantic validity that ehrQL fails to respect:</p> <p>Write a dataset definition that generates a dataset that contains: - a patient's date of birth  - admission date for the patient's first hospital admission - discharge date for the patient's first hospital admission</p> <p>(Note: you will need to use the <code>apcs</code> table). </p> <p>Configure your dummy data with a population size a bit larger than the default, e.g. 30.  </p> <p>Inspect the generated dataset and note that no patients have admission or discharge dates before their date of birth, but some have discharge dates that are before their admission dates. </p>"},{"location":"dummy_data_in_opensafely/#provide-your-own-dummy-dataset","title":"Provide your own dummy dataset","text":"<p>Instead of dummy tables, you can give ehrQL a file containing a dummy dataset. Now, when you run your dataset definition, ehrQL will validate the provided dummy dataset to ensure that all the expected columns are present, and contain data of the expected types, and then will just write out the provided dummy data file as the output dataset.</p>"},{"location":"dummy_data_in_opensafely/#future-direction-for-native-opensafely-dummy-data","title":"Future direction for native OpenSAFELY dummy data","text":"<p>Work is in progress on improving dummy data generation. The first improvements you're likely to see are in efficiency - i.e. making it quicker to generate large amounts of dummy data from complex dataset definitions.</p>"}]}